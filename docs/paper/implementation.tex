In this research, we propose a novel interoperable fuzzing architecture that is
environment- and platform-independent. Our Killerbeez solution disseminates
into four major components of drivers, mutators, instrumentation, a seed
selection algorithm and corpus minimization. A distributed computing model is
achieved by using multiple worker nodes fuzzing in parallel which obtain work
from, and return results to, a central server.

% TODO: Talk about the real power being the ability to mix and match different
%       technologies for different situations

\subsection{Driver}
Driver modules use the mutator module which is passed in to mutate an input,
the instrumentation module to trace the target's execution, and are responsible
for getting the input data into the program.  A simple example would be a
file-based driver, which will create a file containing the mutated input and
use the instrumentation module to launch the application in a way that it will
read this file.  This is typically accomplished by passing a filename in on the
command line.  For targets which do not have any way to specify the input file
on the command line, a custom driver would be required to use keyboard
shortcuts, mouse input, or some other method of getting the file into the
program.

We implemented the following drivers:
\begin{itemize}[noitemsep]
\item \textbf{File} - for programs that read input from a file
\item \textbf{Stdin} - for programs that read input from standard input
\item \textbf{Network Server} - enables fuzzing of server-like programs
\item \textbf{Network Client} - enables fuzzing of client-like programs
\item \textbf{Windows Media Player} - for Windows Media Player
\end{itemize}

\subsection{Mutator}
We leverage the mutators from Honggfuzz, Radamsa, AFL, and Ni by wrapping the
code to be Killerbeez compliant, and exposing them via command-line options. By
defining an API for the mutators, researchers can modify components of other
fuzzers to conform to the Killerbeez API and easily swap in the new mutators.

\begin{itemize}[noitemsep]
\item \textbf{arithmetic} - 32-bit arithmetics, both endians. From \AFL{}
\item \textbf{bit flip} - Flips various number of bits (1-32). From \AFL{}
\item \textbf{dictionary} - Inserts or replaces values from a dictionary. From \AFL{}
\item \textbf{havoc} - Runs multiple mutations on a single input. From \AFL{}
\item \textbf{interesting value} - Values which are more likely to trigger
                                   integer overflows or off-by-one errors. From
                                   \AFL{}
\item \textbf{splice} - Splices two input files together. From \AFL{}
\item \textbf{afl} - All of the \AFL{} mutators, run in the same manner as is
                     done in \AFL{}
\item \textbf{honggfuzz} - All of the mutators from Honggfuzz
\item \textbf{multipart} - Input must be made up of multiple parts, different
                           mutators are applied to different parts of the
                           input. Useful for network protocols where there is
                           a desire to not disrupt the handshake/login
\item \textbf{ni} - The Ni mutator
\item \textbf{nop} - A mutator which does not mutate anything, useful for
                     testing and when combined with the multipart mutator
\item \textbf{radamsa} - Mutator which wraps Radamsa\cite{radamsa}
\item \textbf{zzuf} - Mutation algorithm from zzuf\cite{zzuf}
\end{itemize}

% Talk about the modules

% Mention that we have written a patch to allow Honggfuzz to use Killerbeez modules


\subsection{Instrumentation}
Killerbeez also uses an instrumentation abstraction, to implement the
feedback-based portion of the fuzzer. Instrumentation monitors code coverage of
binaries. It is essential in feedback-based fuzzing because helps expand code
coverage by keeping inputs which reach new code.

We implemented the following instrumentation modules:
\begin{itemize}[noitemsep]
\item \textbf{Debug} - A na\"ive Windows-only instrumentation that uses determine the
	result of a fuzz target via the Windows Debug API.
\item \textbf{Return code} - A Linux-only equivalent to the debug instrumentation that
	uses the waitpid system call to determine the result of a fuzz round.
\item \textbf{DynamoRIO} - An instrumentation that uses the DynamoRIO project to
	determine new paths discovered in a binary.
\item \textbf{Intel PT} - Hardware-level ``Process Tracing'' instrumentation
\item \textbf{AFL} - Instrumentation injected by AFL's compilers (afl-gcc or
	afl-clang-fast)
\end{itemize}

The instrumentation modules monitor, at minimum, whether a process crashed,
exited cleanly, or timed out. More advanced instrumentation modules, such as
DynamoRIO, monitor basic block coverage and can inform the fuzzer of new paths
taken in a binary.

\subsection{Tracer} \label{Tracer}
The tracer runs the fuzz target and takes detailed information on exactly which
edges were executed.  Unlike the instrumentation module, which just gives a
hash or bitmap of what was executed, the tracer shows every basic block that
was hit and in what order.  This information will be fed into the manager,
which will periodically run through all seed files and minimize them to only
include the minimum number of files, and the minimum file size which hits the
maximum amount of code. The concept of minimizing test corpora while
maintaining the maximum code coverage dates back to at least October of 2008,
when Peach Fuzzer version 2.2 was released, which included the minset
tool.\cite{peach22}

The tracer uses the driver to run the fuzzed program (feed the program the
input data, and tell when the program has finished processing it). While the
instrumentation module is built for speed, the tracer is built for high
resolution.  The instrumentation module is used during the main fuzzing
process, and as such only records what is absolutely necessary to do its job.
Meanwhile, the tracer is slow, but gives more granular data about the path
information, which informs smarter mutation of input data.

For example, the instrumentation module may use Intel PT to trace a binary, and
only record a hash of the Trace information.  Instead, the tracer will generate
a list of branch edges that the program takes throughout its execution.
