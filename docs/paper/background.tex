There are a huge number of fuzzing tools\cite{afl,aflosx,winafl,peach22,syzkaller,ossfuzz,driller,radamsa,ni,zzuf,synfuzz,brundlefuzz,honggfuzz,kafl} which are publicly available, many of
which are very useful on real world binaries.
However, each tool
typically only handles one very specific use case or contains other real-world limitations, and most are not designed to scale
out.  For instance, there are a number of system call kernel fuzzers\cite{syzkaller,trinity,kafl,osxfuzz}, different ones for
fuzzing \IOCTLs{}\cite{ioctlfuzzer,ioctlbf}, some userland Linux fuzzers which only effectively work with
command line programs which were written in C or C++.  Some only function with
source code, others only work on 32-bit Linux, or require a person to go
through and describe the format of the data which the target is
expecting.  Finally, there is a category of tools which work amazingly well
on toy programs but do not work on production software due to bugs or lack of
support for features such as multithreading.

This is typically not viewed as an issue in academic work, as the problem to address can be
scoped based on the tools that are available and one may assume that the problem can
be solved in other situations, but leave the proof for ``future work.''  They
are typically correct in their assumption, however practitioners need tools
that work in practice, not theoretical solutions.

In industry, the situation is dictated by the target software,
and there is often not a choice as to what language it is
written in, whether source code is available, what operating system it runs
on, or which CPU architectures it supports. This leaves the security
professional to choose between a limited set of options many of which will
turn out to be mutually exclusive. This also adds to the problem, as a common
response to this dilemma is to put together a custom tool which meets their
needs, and to do so in the shortest amount of time possible.  Furthermore,
this results in the same code being re-written for different platforms, or
sometimes for the same platform simply because the security professional was
unaware of existing implementations.  The new implementation will probably
contain some of the same bugs and limitations that were in the initial
version of the existing tool, which may or may not get fixed before it is
abandoned.

In short, while that state of security research is advancing rapidly, the
tools to bring their benefits to life are sorely lacking.  Though there are some
fuzzing projects which come close, such as OSS-Fuzz,\cite{ossfuzz} there
is not anything which is freely available, works on closed source applications,
and runs against Windows and Linux applications.
